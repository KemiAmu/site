<!doctype html>
<html x-data="app">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Interactive tool for visualizing and rasterizing quadratic Bezier curves"
    />
    <meta name="author" content="Kemi-Amu" />
    <title>Quadratic Bezier Rasterizer</title>
    <link rel="icon" href="../assets/favicon.svg" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css"
    />
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"
    ></script>
    <script>
      document.addEventListener("alpine:init", () => {
        Alpine.data("app", () => ({
          lang: localStorage.getItem("lang"),
          translations: {
            "Quadratic Bezier Rasterizer": {
              zh: "二次贝塞尔曲线光栅化器",
              de: "Quadratischer Bezier-Kurven-Rasterisierer",
            },
            "Generate rasterized paths for quadratic Bezier curves": {
              zh: "生成二次贝塞尔曲线的光栅化路径",
              de: "Rasterisierte Pfade für quadratische Bezier-Kurven generieren",
            },
            "Start Point": {
              zh: "起点",
              de: "Startpunkt",
            },
            "End Point": {
              zh: "终点",
              de: "Endpunkt",
            },
            Point: {
              zh: "点",
              de: "Punkt",
            },
            "Control Handle": {
              zh: "控制点",
              de: "Kontrollpunkt",
            },
            "Rasterized Path Steps": {
              zh: "光栅化路径步骤",
              de: "Rasterisierte Pfadschritte",
            },
            "Step length": {
              zh: "步长",
              de: "Schrittlänge",
            },
            Power: {
              zh: "次数",
              de: "Anzahl",
            },
            "← Back to Home": {
              zh: "← 返回首页",
              de: "← Zurück zur Startseite",
            },
          },
          t(key) {
            return this.translations[key]?.[this.lang] || key;
          },
          points: [
            [null, null],
            [null, null],
            [null, null],
          ],
          steps: [],

          init() {
            this.update();
          },
          update() {
            // Create a copy of points to avoid modifying the original before processing
            const processedPoints = this.points.map((point, i) => {
              if (!point) return [0, 0];
              return [
                point[0] === null || isNaN(point[0]) ? 0 : point[0],
                point[1] === null || isNaN(point[1]) ? 0 : point[1],
              ];
            });

            this.calculateSteps(processedPoints);
          },

          calculateSteps(points) {
            if (points.length < 3) return [];
            this.steps = this.rasterizedBezierSteps(...points);
          },

          rasterizedBezierSteps(p0, p1, p2) {
            if (!p0 || !p1 || !p2) return [];

            const plotLine = (p0, p1) => {
              let x = Math.round(p0[0]),
                y = Math.round(p0[1]);
              const dx = Math.abs(p0[0] - p1[0]),
                dy = Math.abs(p0[1] - p1[1]);
              const sx = p0[0] < p1[0] ? 1 : -1,
                sy = p0[1] < p1[1] ? 1 : -1;
              let err =
                0.5 * (dx - dy) + dy * sx * (p0[0] - x) - dx * sy * (p0[1] - y);
              const points = [];
              const steps =
                Math.abs(x - Math.round(p1[0])) +
                Math.abs(y - Math.round(p1[1]));

              for (let i = 0; i < steps; i++) {
                if (err < 0) {
                  y += sy;
                  err += dx;
                } else {
                  x += sx;
                  err -= dy;
                }
                points.push([x, y]);
              }
              return points;
            };

            const calculateBezierPoint = (p0, p1, p2, t) => {
              const u = 1 - t;
              return [
                u * u * p0[0] + 2 * u * t * p1[0] + t * t * p2[0],
                u * u * p0[1] + 2 * u * t * p1[1] + t * t * p2[1],
              ];
            };

            const adaptiveBezierPath = (p0, p1, p2) => {
              const curve = [p0];
              const stack = [
                [0.5, 1.0],
                [0.0, 0.5],
              ];

              while (stack.length) {
                const [t0, t1] = stack.pop();
                const tm = (t0 + t1) / 2;
                const p_start = curve[curve.length - 1];
                const p_end = calculateBezierPoint(p0, p1, p2, t1);
                const p_mid = calculateBezierPoint(p0, p1, p2, tm);
                const mid = [
                  (p_start[0] + p_end[0]) / 2,
                  (p_start[1] + p_end[1]) / 2,
                ];
                const dist =
                  (p_mid[0] - mid[0]) ** 2 + (p_mid[1] - mid[1]) ** 2;

                dist < 0.001
                  ? curve.push(p_end)
                  : (stack.push([tm, t1]), stack.push([t0, tm]));
              }
              return curve;
            };

            const calculateDeltas = (points) => {
              const deltas = [];
              for (let i = 1; i < points.length; i++) {
                const dx = points[i][0] - points[i - 1][0];
                const dy = points[i][1] - points[i - 1][1];
                deltas.push([dx, dy]);
              }
              return deltas;
            };

            const calculateStepCounts = (deltas) => {
              const steps = [];
              let currentCount = 1;
              for (let i = 1; i < deltas.length; i++) {
                if (
                  deltas[i][0] === deltas[i - 1][0] &&
                  deltas[i][1] === deltas[i - 1][1]
                ) {
                  currentCount++;
                } else {
                  steps.push(currentCount);
                  currentCount = 1;
                }
              }
              if (deltas.length > 0) {
                steps.push(currentCount);
              }
              return steps;
            };

            const formatResultSteps = (steps) => {
              const resultSteps = [];
              let currentCount = 1;
              for (let i = 1; i < steps.length; i++) {
                if (steps[i] === steps[i - 1]) {
                  currentCount++;
                } else {
                  resultSteps.push([Math.abs(steps[i - 1]), currentCount]);
                  currentCount = 1;
                }
              }
              if (steps.length > 0) {
                resultSteps.push([
                  Math.abs(steps[steps.length - 1]),
                  currentCount,
                ]);
              }
              return resultSteps;
            };

            const curve = adaptiveBezierPath(p0, p1, p2);
            const points = [[Math.round(p0[0]), Math.round(p0[1])]].concat(
              curve.flatMap((start, i, arr) =>
                i < arr.length - 1 ? plotLine(start, arr[i + 1]) : [],
              ),
            );

            const deltas = calculateDeltas(points);
            const steps = calculateStepCounts(deltas);
            return formatResultSteps(steps);
          },
        }));
      });
    </script>
  </head>
  <body class="container" x-data="app">
    <main>
      <hgroup>
        <h1 x-text="t('Quadratic Bezier Rasterizer')"></h1>
        <h2
          x-text="t('Generate rasterized paths for quadratic Bezier curves')"
        ></h2>
      </hgroup>

      <div class="grid">
        <div>
          <article>
            <label>
              <span x-text="t('Start Point')"></span>
              <input
                type="number"
                x-model.number="points[0][0]"
                @input="update()"
                placeholder="X"
              />
              <input
                type="number"
                x-model.number="points[0][1]"
                @input="update()"
                placeholder="Y"
              />
            </label>

            <label>
              <span x-text="t('Control Handle')"></span>
              <input
                type="number"
                x-model.number="points[1][0]"
                @input="update()"
                placeholder="X"
              />
              <input
                type="number"
                x-model.number="points[1][1]"
                @input="update()"
                placeholder="Y"
              />
            </label>
            <label>
              <span x-text="t('End Point')"></span>
              <input
                type="number"
                x-model.number="points[2][0]"
                @input="update()"
                placeholder="X"
              />
              <input
                type="number"
                x-model.number="points[2][1]"
                @input="update()"
                placeholder="Y"
              />
            </label>
          </article>
        </div>

        <div>
          <h3 x-text="t('Rasterized Path Steps')"></h3>
          <table>
            <thead>
              <tr>
                <th x-text="t('Step length')"></th>
                <th x-text="t('Power')"></th>
              </tr>
            </thead>
            <tbody>
              <template x-for="step in steps">
                <tr>
                  <td x-text="step[0]"></td>
                  <td x-text="step[1] === 1 ? '' : step[1]"></td>
                </tr>
              </template>
            </tbody>
          </table>
        </div>
      </div>
    </main>

    <footer>
      <p><a href="../" x-text="t('← Back to Home')"></a></p>
      <p>
        <a @click="lang = 'en'; localStorage.setItem('lang', 'en')">
          English
        </a>
        /
        <a @click="lang = 'zh'; localStorage.setItem('lang', 'zh')"> 中文 </a>
        /
        <a @click="lang = 'de'; localStorage.setItem('lang', 'de')">
          Deutsch
        </a>
      </p>
    </footer>
  </body>
</html>
