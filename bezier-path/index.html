<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta
			name="description"
			content="Interactive tool for visualizing and rasterizing cubic Bezier curves"
		/>
		<meta name="author" content="Kemi-Amu" />
		<title>Bezier Curve Rasterizer</title>
		<link rel="icon" href="../assets/favicon.svg" />
		<link
			rel="stylesheet"
			href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css"
		/>
		<script
			defer
			src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"
		></script>
		<script>
			document.addEventListener("alpine:init", () => {
				Alpine.data("app", () => ({
					points: [
						[null, null],
						[null, null],
						[null, null],
						[null, null],
					],
					steps: [],

					init() {
						this.update();
					},
					update() {
						// Create a copy of points to avoid modifying the original before processing
						const processedPoints = this.points.map((point, i) => {
							if (!point) return [0, 0];
							return [
								point[0] === null || isNaN(point[0])
									? i === 1
										? this.points[0][0]
										: i === 2
											? this.points[3][0]
											: 0
									: point[0],
								point[1] === null || isNaN(point[1])
									? i === 1
										? this.points[0][1]
										: i === 2
											? this.points[3][1]
											: 0
									: point[1],
							];
						});

						// If control handles are completely empty, set them to their corresponding points
						if (!this.points[1]) {
							processedPoints[1] = [
								this.points[0][0] ?? 0,
								this.points[0][1] ?? 0,
							];
						}
						if (!this.points[2]) {
							processedPoints[2] = [
								this.points[3][0] ?? 0,
								this.points[3][1] ?? 0,
							];
						}

						this.calculateSteps(processedPoints);
					},

					calculateSteps(points) {
						if (points.length < 4) return [];
						this.steps = this.rasterizedBezierSteps(...points);
					},

					rasterizedBezierSteps(p0, p1, p2, p3) {
						if (!p0 || !p1 || !p2 || !p3) return [];

						const plotLine = (p0, p1) => {
							let x = Math.round(p0[0]),
								y = Math.round(p0[1]);
							const dx = Math.abs(p0[0] - p1[0]),
								dy = Math.abs(p0[1] - p1[1]);
							const sx = p0[0] < p1[0] ? 1 : -1,
								sy = p0[1] < p1[1] ? 1 : -1;
							let err =
								0.5 * (dx - dy) +
								dy * sx * (p0[0] - x) -
								dx * sy * (p0[1] - y);
							const points = [];
							const steps =
								Math.abs(x - Math.round(p1[0])) +
								Math.abs(y - Math.round(p1[1]));

							for (let i = 0; i < steps; i++) {
								if (err < 0) {
									y += sy;
									err += dx;
								} else {
									x += sx;
									err -= dy;
								}
								points.push([x, y]);
							}
							return points;
						};

						const calculateBezierPoint = (p0, p1, p2, p3, t) => {
							const u = 1 - t;
							return [
								u ** 3 * p0[0] +
									3 * u ** 2 * t * p1[0] +
									3 * u * t ** 2 * p2[0] +
									t ** 3 * p3[0],
								u ** 3 * p0[1] +
									3 * u ** 2 * t * p1[1] +
									3 * u * t ** 2 * p2[1] +
									t ** 3 * p3[1],
							];
						};

						const adaptiveBezierPath = (p0, p1, p2, p3) => {
							const curve = [p0];
							const stack = [
								[0.5, 1.0],
								[0.0, 0.5],
							];

							while (stack.length) {
								const [t0, t1] = stack.pop();
								const tm = (t0 + t1) / 2;
								const p_start = curve[curve.length - 1];
								const p_end = calculateBezierPoint(
									p0,
									p1,
									p2,
									p3,
									t1,
								);
								const p_mid = calculateBezierPoint(
									p0,
									p1,
									p2,
									p3,
									tm,
								);
								const mid = [
									(p_start[0] + p_end[0]) / 2,
									(p_start[1] + p_end[1]) / 2,
								];
								const dist =
									(p_mid[0] - mid[0]) ** 2 +
									(p_mid[1] - mid[1]) ** 2;

								dist < 0.001
									? curve.push(p_end)
									: (stack.push([tm, t1]),
										stack.push([t0, tm]));
							}
							return curve;
						};

						const calculateDeltas = (points) => {
							const deltas = [];
							for (let i = 1; i < points.length; i++) {
								const dx = points[i][0] - points[i - 1][0];
								const dy = points[i][1] - points[i - 1][1];
								deltas.push([dx, dy]);
							}
							return deltas;
						};

						const calculateStepCounts = (deltas) => {
							const steps = [];
							let currentCount = 1;
							for (let i = 1; i < deltas.length; i++) {
								if (
									deltas[i][0] === deltas[i - 1][0] &&
									deltas[i][1] === deltas[i - 1][1]
								) {
									currentCount++;
								} else {
									steps.push(currentCount);
									currentCount = 1;
								}
							}
							if (deltas.length > 0) {
								steps.push(currentCount);
							}
							return steps;
						};

						const formatResultSteps = (steps) => {
							const resultSteps = [];
							let currentCount = 1;
							for (let i = 1; i < steps.length; i++) {
								if (steps[i] === steps[i - 1]) {
									currentCount++;
								} else {
									resultSteps.push([
										Math.abs(steps[i - 1]),
										currentCount,
									]);
									currentCount = 1;
								}
							}
							if (steps.length > 0) {
								resultSteps.push([
									Math.abs(steps[steps.length - 1]),
									currentCount,
								]);
							}
							return resultSteps;
						};

						const curve = adaptiveBezierPath(p0, p1, p2, p3);
						const points = [
							[Math.round(p0[0]), Math.round(p0[1])],
						].concat(
							curve.flatMap((start, i, arr) =>
								i < arr.length - 1
									? plotLine(start, arr[i + 1])
									: [],
							),
						);

						const deltas = calculateDeltas(points);
						const steps = calculateStepCounts(deltas);
						return formatResultSteps(steps);
					},
				}));
			});
		</script>
	</head>
	<body class="container" x-data="app">
		<main>
			<hgroup>
				<h1>Bezier Curve Rasterizer</h1>
				<h2>Generate rasterized paths for cubic Bezier curves</h2>
			</hgroup>

			<div class="grid">
				<div>
					<article>
						<header>
							<h2>Start Point</h2>
						</header>
						<label>
							Point
							<input
								type="number"
								x-model.number="points[0][0]"
								@input="update()"
								placeholder="X"
							/>
							<input
								type="number"
								x-model.number="points[0][1]"
								@input="update()"
								placeholder="Y"
							/>
						</label>
						<label>
							Control Handle
							<input
								type="number"
								x-model.number="points[1][0]"
								@input="update()"
								placeholder="X"
							/>
							<input
								type="number"
								x-model.number="points[1][1]"
								@input="update()"
								placeholder="Y"
							/>
						</label>
					</article>
				</div>

				<div>
					<article>
						<header>
							<h2>End Point</h2>
						</header>
						<label>
							Point
							<input
								type="number"
								x-model.number="points[3][0]"
								@input="update()"
								placeholder="X"
							/>
							<input
								type="number"
								x-model.number="points[3][1]"
								@input="update()"
								placeholder="Y"
							/>
						</label>
						<label>
							Control Handle
							<input
								type="number"
								x-model.number="points[2][0]"
								@input="update()"
								placeholder="X"
							/>
							<input
								type="number"
								x-model.number="points[2][1]"
								@input="update()"
								placeholder="Y"
							/>
						</label>
					</article>
				</div>

				<div>
					<h3>Rasterized Path Steps</h3>
					<table>
						<thead>
							<tr>
								<th>Steps</th>
								<th>Count</th>
							</tr>
						</thead>
						<tbody>
							<template x-for="step in steps">
								<tr>
									<td x-text="step[0]"></td>
									<td x-text="step[1]"></td>
								</tr>
							</template>
						</tbody>
					</table>
				</div>
			</div>
		</main>

		<footer>
			<p><a href="../">‚Üê Back to Home</a></p>
		</footer>
	</body>
</html>
